<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title><strong>rfmt</strong>: A new formatter for R</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{rfmt - A new formatter for R}
-->

<h1><strong>rfmt</strong>: A new formatter for R</h1>

<p>The <strong>rfmt</strong> package is intended to improve automatically the formatting of R code to aid readability. It shares many of the objectives of the <strong>formatR</strong> package, though with its more sophisticated layout algorithm (documented in <a href="http://research.google.com/pubs/pub44667.html">this technical report</a>, also included in the package documentation) and flexible approach to code formatting (described below), it aims to produce more &ldquo;aesthetically appealing&#39;&#39; results.</p>

<h2>Installation</h2>

<hr/>

<p><em>To be completed</em></p>

<p>Like all R packages, <strong>rfmt</strong> is available from <a href="http://cran.rstudio.com/package=rfmt">CRAN</a>, and can be installed simply using R&#39;s <code>install.packages</code> function:</p>

<pre><code class="r">install.packages(&quot;rfmt&quot;)
library(rfmt)
</code></pre>

<hr/>

<p>If you&#39;d like to download the latest development version of <strong>rfmt</strong>, it&#39;s 
to be found in this <a href="https://github.com/google/rfmt">Google repository on GitHub</a>. To install from GitHub, either check out the repository and install from source using <code>install.packages</code> or install directly using R&#39;s <a href="https://cran.r-project.org/web/packages/devtools/index.html">devtools</a> package:</p>

<pre><code class="r">require(devtools)
install_github(&quot;google/rfmt&quot;)
library(rfmt)
</code></pre>

<h3>Python</h3>

<p>Unlike the majority of R packages, much of <strong>rfmt</strong> is implemented in the <a href="https://www.python.org/">Python</a> programming language. In contrast to R, Python is reasonably well suited to the sort of fine-grained iterative processing required in <strong>rfmt</strong>&#39;s layout algorithms, and there are a selection of compiler generators in Python the support the analysis of R code necessary for proper layout. Generally, package implementors turn to C or C++ to circumvent these and similar shortcomings in R, but we found it much easier to rework our formatting algorithms in Python than in C/C++. Ease of rework is important in code formatting, which is an inherently subjective exercise; in the last analysis, the only real way of validating the output of a formatter is to present it to prospective users, and to address any objections by amending the program.</p>

<p>Consequently, to use <strong>rfmt</strong>, you&#39;ll need to have a Python (v. 2.7 or later) installation available (in fact the library will complain if it&#39;s unable to find one). This is usually the case, but if it isn&#39;t, you can download one yourself from <a href="https://www.python.org/downloads/release/python-2711/">python.org</a>.</p>

<h2>Usage</h2>

<p>Once installed, you can use <strong>rfmt</strong> in three ways:</p>

<ol>
<li>From R, format a single file using the <code>rfmt()</code> function, or format all source files in a directory with the <code>rfmtdir()</code> function.</li>
<li>On systems (in particular, Linux and OS/X, or Windows with <a href="https://www.cygwin.com/">Cygwin</a>) with the <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell">bash shell</a> or <a href="https://en.wikipedia.org/wiki/C_shell">C shell</a>, the <code>install_rfmt_shell()</code> function in R makes the command <code>rfmt</code> available from the command line.</li>
<li>You can use <strong>rfmt</strong> to layout code as you edit in <code>vim</code> or <code>emacs</code>.</li>
</ol>

<p>These choices are described in detail in the following sections.</p>

<h3>Formatting files and directories from R</h3>

<p>The function <code>rfmt()</code> allows you to format a file, a string or the contents of the clipboard. For example, the file <code>test.R</code>, supplied with the package, contains the following (rather eccentrically) formatted code:</p>

<pre><code class="r">## Not run:
new.data &lt;- new.data[,object$vars$all,drop = FALSE]

if(others &gt; 0 &amp;&amp; others &lt; 10) { object$model &lt;- gsub(&quot;parm1&quot;, # Alter model in accordance with new data
                       paste(&quot;parm1=&quot;,
                             others, 
                             sep = &quot;&quot;),
                       object$model)}

## Make data file
data.fn &lt;- makeNewDataFile(x = newdata, 
    y = NULL)

## Finally, compute forecast for new data
Z &lt;- .C(&quot;forecast&quot;, # See src/top.c
      as.character(data.fn),
        as.character(object$names), as.character(object$data),
            as.character(object$model),
                pred = double(nrow(new.data)),    
                    output = character(1),
                        PACKAGE = &quot;test&quot;      )
## End(**Not run**)
</code></pre>

<p>The following code copies this file to a temporary location, and calls <code>rfmt()</code> to format it, printing the result to the console:</p>

<pre><code class="r">fn &lt;- tempfile()
file.copy(system.file(&quot;demo&quot;, &quot;test.R&quot;, package = &quot;rfmt&quot;), fn)
rfmt(fn)
cat(readLines(fn), sep = &quot;\n&quot;)
</code></pre>

<p>The result you see should closely resemble the following:</p>

<pre><code class="r">## Not run:
new.data &lt;- new.data[, object$vars$all, drop = FALSE]

if (others &gt; 0 &amp;&amp; others &lt; 10) {
  object$model &lt;- gsub(&quot;parm1&quot;,  # Alter model in accordance with new data
                       paste(&quot;parm1=&quot;, others, sep = &quot;&quot;), object$model)
}

## Make data file
data.fn &lt;- makeNewDataFile(x = newdata, y = NULL)

## Finally, compute forecast for new data
Z &lt;- .C(&quot;forecast&quot;,  # See src/top.c
        as.character(data.fn), as.character(object$names),
        as.character(object$data), as.character(object$model),
        pred = double(nrow(new.data)), output = character(1), PACKAGE = &quot;test&quot;)
## End(**Not run**)
</code></pre>

<p>You can provide a string to the formatter directly using the <code>text</code> argument of <code>rfmt()</code>; with neither file name nor text provided, the function formats the contents of the system clipboard. In both these cases, the output of the formatter is printed to the console and returned (invisibly, in the latter case) as a <code>character</code> vector.</p>

<p>To format all the R source files in a directory, use the <code>rfmt_dir()</code> function. This searches a directory for file names that conform to a given pattern (by default, files with extensions &rdquo;.R&quot;, &ldquo;.r&rdquo;, &ldquo;.S&rdquo; or &ldquo;.s&rdquo;) and formats them each in turn.</p>

<h3>From the command line</h3>

<p>It&#39;s also possible to use it directly from the command line. To facilitate this, the package provides a function <code>install_rfmt_shell()</code> that (by default) makes the formatter available as the <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell">bash shell</a> command <code>rfmt</code> for use on Linux and OS/X systems (provided you&#39;re using the bash shell, of course). Simply invoking <code>install_rfmt_shell()</code> will add the appropriate definitions to your <code>.bashrc</code> file. Opening a new shell or <code>source</code>ing your <code>.bashrc</code> thereafter will allow you to use the command <code>rfmt fn1 ... fnn</code> to format the files <code>fn1</code> &hellip; <code>fnn</code>. (Note that by supplying the argument <code>shellrc = &quot;.cshrc&quot;</code> to <code>install_rfmt_shell()</code>, you can provide <code>rfmt</code> to the <a href="https://en.wikipedia.org/wiki/C_shell">C shell</a>, too.)</p>

<h3>Editor integration</h3>

<p>If you&#39;re a user of the <a href="https://www.gnu.org/software/emacs/">Emacs</a> or <a href="http://www.vim.org/">Vim</a> editors, the package offers two functions, <code>install_rfmt_emacs()</code> and <code>install_rfmt_vim()</code>, that make the formatter available in each of those editors (use the key combination <code>Ctrl-x Ctrl-i</code> to format the current buffer in Emacs, and <code>Ctrl-I</code> in Vim). Calling these functions in R will add the appropriate initialization code to the respective editor&#39;s initialization file (<code>~/.vimrc</code> in the case of Vim, and <code>~/.emacs</code> or <code>~/.emacs.d/init.el</code> for Emacs), making a back-up copy of the original.</p>

<h2>Formatting options</h2>

<p>A number of aspects of the formatter&#39;s behavior may be affected by setting options in R (using the function <code>option_rfmt()</code>), on the command line, in the environment variable <code>RFMTOPTS</code> or in an initialization file (by default, <code>~/.rfmtrc</code>, or a file named by the environment variable <code>RFMTRC</code>).</p>

<table><thead>
<tr>
<th>Option</th>
<th>Default value</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>backup</td>
<td>TRUE</td>
<td>Backup source &#39;FILE&#39; to &#39;FILE.bak&#39; before formatting</td>
</tr>
<tr>
<td>margin0</td>
<td>0</td>
<td>Position of the first (<em>soft</em>) right margin</td>
</tr>
<tr>
<td>margin1</td>
<td>80</td>
<td>Position of the second (<em>hard</em>) right margin</td>
</tr>
<tr>
<td>cost0</td>
<td>0.05</td>
<td>Cost (per character) beyond margin 0</td>
</tr>
<tr>
<td>cost1</td>
<td>100</td>
<td>Cost (per character) beyond margin 1</td>
</tr>
<tr>
<td>costb</td>
<td>2</td>
<td>Cost per line break</td>
</tr>
<tr>
<td>indent</td>
<td>2</td>
<td>Number of spaces for each indent</td>
</tr>
<tr>
<td>force.brace</td>
<td>0</td>
<td>Ensure that control flow constructs have braces</td>
</tr>
<tr>
<td>space.arg.eq</td>
<td>1</td>
<td>Ensure spaces around equals signs in arguments</td>
</tr>
<tr>
<td>quiet</td>
<td>1</td>
<td>Suppress all diagnostic messages</td>
</tr>
<tr>
<td>adj.comment</td>
<td>0.5</td>
<td>Adjustment to line break cost in inline comments</td>
</tr>
<tr>
<td>adj.flow</td>
<td>0.3</td>
<td>Adjustment to line break cost in control flow constructs</td>
</tr>
<tr>
<td>adj.call</td>
<td>0.5</td>
<td>Adjustment to line break cost in function calls</td>
</tr>
<tr>
<td>adj.arg</td>
<td>5</td>
<td>Adjustment to line break cost in argument expressions</td>
</tr>
<tr>
<td>cpack</td>
<td>0.001</td>
<td>Cost used to pack elements in justified layouts</td>
</tr>
</tbody></table>

</body>

</html>
